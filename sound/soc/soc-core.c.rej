--- sound/soc/soc-core.c
+++ sound/soc/soc-core.c
@@ -781,26 +870,23 @@
 				struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
 
-	if (machine->ops && machine->ops->hw_params) {
-		ret = machine->ops->hw_params(substream, params);
+	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_params) {
+		ret = rtd->dai_link->ops->hw_params(substream, params);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: machine hw_params failed\n");
 			goto out;
 		}
 	}
 
-	if (codec_dai->ops->hw_params) {
-		ret = codec_dai->ops->hw_params(substream, params, codec_dai);
+	if (codec_dai->driver->ops->hw_params) {
+		ret = codec_dai->driver->ops->hw_params(substream, params, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
 				codec_dai->name);
@@ -887,28 +970,25 @@
 static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_card *card= socdev->card;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret;
 
-	if (codec_dai->ops->trigger) {
-		ret = codec_dai->ops->trigger(substream, cmd, codec_dai);
+	if (codec_dai->driver->ops->trigger) {
+		ret = codec_dai->driver->ops->trigger(substream, cmd, codec_dai);
 		if (ret < 0)
 			return ret;
 	}
 
-	if (platform->pcm_ops->trigger) {
-		ret = platform->pcm_ops->trigger(substream, cmd);
+	if (platform->driver->ops->trigger) {
+		ret = platform->driver->ops->trigger(substream, cmd);
 		if (ret < 0)
 			return ret;
 	}
 
-	if (cpu_dai->ops->trigger) {
-		ret = cpu_dai->ops->trigger(substream, cmd, cpu_dai);
+	if (cpu_dai->driver->ops->trigger) {
+		ret = cpu_dai->driver->ops->trigger(substream, cmd, cpu_dai);
 		if (ret < 0)
 			return ret;
 	}
@@ -963,104 +1040,111 @@
 static int soc_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
-	struct snd_soc_codec *codec = card->codec;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
 	int i;
 
 	/* If the initialization of this soc device failed, there is no codec
 	 * associated with it. Just bail out in this case.
 	 */
-	if (!codec)
+	if (list_empty(&card->codec_dev_list))
 		return 0;
 
 	/* Due to the resume being scheduled into a workqueue we could
 	* suspend before that's finished - wait for it to complete.
 	 */
-	snd_power_lock(codec->card);
-	snd_power_wait(codec->card, SNDRV_CTL_POWER_D0);
-	snd_power_unlock(codec->card);
+	snd_power_lock(card->snd_card);
+	snd_power_wait(card->snd_card, SNDRV_CTL_POWER_D0);
+	snd_power_unlock(card->snd_card);
 
 	/* we're going to block userspace touching us until resume completes */
-	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D3hot);
+	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D3hot);
 
 	/* mute any active DAC's */
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *dai = card->rtd[i].codec_dai;
+		struct snd_soc_dai_driver *drv = dai->driver;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (dai->ops->digital_mute && dai->playback.active)
-			dai->ops->digital_mute(dai, 1);
+		if (drv->ops->digital_mute && dai->playback_active)
+			drv->ops->digital_mute(dai, 1);
 	}
 
 	/* suspend all pcms */
-	for (i = 0; i < card->num_links; i++) {
-		if (card->dai_link[i].ignore_suspend)
+	for (i = 0; i < card->num_rtd; i++) {
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		snd_pcm_suspend_all(card->dai_link[i].pcm);
+		snd_pcm_suspend_all(card->rtd[i].pcm);
 	}
 
 	if (card->suspend_pre)
 		card->suspend_pre(pdev, PMSG_SUSPEND);
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai  *cpu_dai = card->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_platform *platform = card->rtd[i].platform;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->suspend && !cpu_dai->ac97_control)
-			cpu_dai->suspend(cpu_dai);
-		if (platform->suspend)
-			platform->suspend(&card->dai_link[i]);
+		if (cpu_dai->driver->suspend && !cpu_dai->driver->ac97_control)
+			cpu_dai->driver->suspend(cpu_dai);
+		if (platform->driver->suspend && !platform->suspended) {
+			platform->driver->suspend(cpu_dai);
+			platform->suspended = 1;
+		}
 	}
 
 	/* close any waiting streams and save state */
-	run_delayed_work(&card->delayed_work);
-	codec->suspend_bias_level = codec->bias_level;
+	for (i = 0; i < card->num_rtd; i++) {
+		run_delayed_work(&card->rtd[i].delayed_work);
+		card->rtd[i].codec->suspend_bias_level = card->rtd[i].codec->bias_level;
+	}
 
-	for (i = 0; i < codec->num_dai; i++) {
-		char *stream = codec->dai[i].playback.stream_name;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (stream != NULL)
-			snd_soc_dapm_stream_event(codec, stream,
+		if (driver->playback.stream_name != NULL)
+			snd_soc_dapm_stream_event(&card->rtd[i], driver->playback.stream_name,
 				SND_SOC_DAPM_STREAM_SUSPEND);
-		stream = codec->dai[i].capture.stream_name;
-		if (stream != NULL)
-			snd_soc_dapm_stream_event(codec, stream,
+
+		if (driver->capture.stream_name != NULL)
+			snd_soc_dapm_stream_event(&card->rtd[i], driver->capture.stream_name,
 				SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
-	/* If there are paths active then the CODEC will be held with
-	 * bias _ON and should not be suspended. */
-	if (codec_dev->suspend) {
-		switch (codec->bias_level) {
-		case SND_SOC_BIAS_STANDBY:
-		case SND_SOC_BIAS_OFF:
-			codec_dev->suspend(pdev, PMSG_SUSPEND);
-			break;
-		default:
-			dev_dbg(socdev->dev, "CODEC is on over suspend\n");
-			break;
+	/* suspend all CODECs */
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_codec *codec = card->rtd[i].codec;
+		/* If there are paths active then the CODEC will be held with
+		 * bias _ON and should not be suspended. */
+		if (!codec->suspended && codec->driver->suspend) {
+			switch (codec->bias_level) {
+			case SND_SOC_BIAS_STANDBY:
+			case SND_SOC_BIAS_OFF:
+				codec->driver->suspend(codec, PMSG_SUSPEND);
+				codec->suspended = 1;
+				break;
+			default:
+				dev_dbg(codec->dev, "CODEC is on over suspend\n");
+				break;
+			}
 		}
 	}
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->suspend && cpu_dai->ac97_control)
-			cpu_dai->suspend(cpu_dai);
+		if (cpu_dai->driver->suspend && cpu_dai->driver->ac97_control)
+			cpu_dai->driver->suspend(cpu_dai);
 	}
 
 	if (card->suspend_post)
@@ -1074,127 +1158,127 @@
  */
 static void soc_resume_deferred(struct work_struct *work)
 {
-	struct snd_soc_card *card = container_of(work,
-						 struct snd_soc_card,
-						 deferred_resume_work);
-	struct snd_soc_device *socdev = card->socdev;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
-	struct snd_soc_codec *codec = card->codec;
-	struct platform_device *pdev = to_platform_device(socdev->dev);
+	struct snd_soc_card *card =
+			container_of(work, struct snd_soc_card, deferred_resume_work);
+	struct platform_device *pdev = to_platform_device(card->dev);
 	int i;
 
 	/* our power state is still SNDRV_CTL_POWER_D3hot from suspend time,
 	 * so userspace apps are blocked from touching us
 	 */
 
-	dev_dbg(socdev->dev, "starting resume work\n");
+	dev_dbg(card->dev, "starting resume work\n");
 
 	/* Bring us up into D2 so that DAPM starts enabling things */
-	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D2);
+	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D2);
 
 	if (card->resume_pre)
 		card->resume_pre(pdev);
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+	/* resume AC97 DAIs */
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->resume && cpu_dai->ac97_control)
-			cpu_dai->resume(cpu_dai);
-	}
-
-	/* If the CODEC was idle over suspend then it will have been
-	 * left with bias OFF or STANDBY and suspended so we must now
-	 * resume.  Otherwise the suspend was suppressed.
-	 */
-	if (codec_dev->resume) {
-		switch (codec->bias_level) {
-		case SND_SOC_BIAS_STANDBY:
-		case SND_SOC_BIAS_OFF:
-			codec_dev->resume(pdev);
-			break;
-		default:
-			dev_dbg(socdev->dev, "CODEC was on over suspend\n");
-			break;
+		if (cpu_dai->driver->resume && cpu_dai->driver->ac97_control)
+			cpu_dai->driver->resume(cpu_dai);
+	}
+
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_codec *codec = card->rtd[i].codec;
+		/* If the CODEC was idle over suspend then it will have been
+		 * left with bias OFF or STANDBY and suspended so we must now
+		 * resume.  Otherwise the suspend was suppressed.
+		 */
+		if (codec->driver->resume && codec->suspended) {
+			switch (codec->bias_level) {
+			case SND_SOC_BIAS_STANDBY:
+			case SND_SOC_BIAS_OFF:
+				codec->driver->resume(codec);
+				codec->suspended = 0;
+				break;
+			default:
+				dev_dbg(codec->dev, "CODEC was on over suspend\n");
+				break;
+			}
 		}
 	}
 
-	for (i = 0; i < codec->num_dai; i++) {
-		char *stream = codec->dai[i].playback.stream_name;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (stream != NULL)
-			snd_soc_dapm_stream_event(codec, stream,
+		if (driver->playback.stream_name != NULL)
+			snd_soc_dapm_stream_event(&card->rtd[i], driver->playback.stream_name,
 				SND_SOC_DAPM_STREAM_RESUME);
-		stream = codec->dai[i].capture.stream_name;
-		if (stream != NULL)
-			snd_soc_dapm_stream_event(codec, stream,
+
+		if (driver->capture.stream_name != NULL)
+			snd_soc_dapm_stream_event(&card->rtd[i], driver->capture.stream_name,
 				SND_SOC_DAPM_STREAM_RESUME);
 	}
 
 	/* unmute any active DACs */
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *dai = card->rtd[i].codec_dai;
+		struct snd_soc_dai_driver *drv = dai->driver;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (dai->ops->digital_mute && dai->playback.active)
-			dai->ops->digital_mute(dai, 0);
+		if (drv->ops->digital_mute && dai->playback_active)
+			drv->ops->digital_mute(dai, 0);
 	}
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_platform *platform = card->rtd[i].platform;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->resume && !cpu_dai->ac97_control)
-			cpu_dai->resume(cpu_dai);
-		if (platform->resume)
-			platform->resume(&card->dai_link[i]);
+		if (cpu_dai->driver->resume && !cpu_dai->driver->ac97_control)
+			cpu_dai->driver->resume(cpu_dai);
+		if (platform->driver->resume && platform->suspended) {
+			platform->driver->resume(cpu_dai);
+			platform->suspended = 0;
+		}
 	}
 
 	if (card->resume_post)
 		card->resume_post(pdev);
 
-	dev_dbg(socdev->dev, "resume work completed\n");
+	dev_dbg(card->dev, "resume work completed\n");
 
 	/* userspace can access us now we are back as we were before */
-	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D0);
+	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
 }
 
 /* powers up audio subsystem after a suspend */
 static int soc_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_dai *cpu_dai = card->dai_link[0].cpu_dai;
-
-	/* If the initialization of this soc device failed, there is no codec
-	 * associated with it. Just bail out in this case.
-	 */
-	if (!card->codec)
-		return 0;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	int i;
 
 	/* AC97 devices might have other drivers hanging off them so
 	 * need to resume immediately.  Other drivers don't have that
 	 * problem and may take a substantial amount of time to resume
 	 * due to I/O costs and anti-pop so handle them out of line.
 	 */
-	if (cpu_dai->ac97_control) {
-		dev_dbg(socdev->dev, "Resuming AC97 immediately\n");
-		soc_resume_deferred(&card->deferred_resume_work);
-	} else {
-		dev_dbg(socdev->dev, "Scheduling resume work\n");
-		if (!schedule_work(&card->deferred_resume_work))
-			dev_err(socdev->dev, "resume work item may be lost\n");
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		if (cpu_dai->driver->ac97_control) {
+			dev_dbg(dev, "Resuming AC97 immediately\n");
+			soc_resume_deferred(&card->deferred_resume_work);
+		} else {
+			dev_dbg(dev, "Scheduling resume work\n");
+			if (!schedule_work(&card->deferred_resume_work))
+				dev_err(dev, "resume work item may be lost\n");
+		}
 	}
 
 	return 0;
@@ -1659,15 +1987,15 @@
 /* probes a new socdev */
 static int soc_probe(struct platform_device *pdev)
 {
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
 	int ret = 0;
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
-
-	/* Bodge while we push things out of socdev */
-	card->socdev = socdev;
 
 	/* Bodge while we unpick instantiation */
 	card->dev = &pdev->dev;
+	INIT_LIST_HEAD(&card->dai_dev_list);
+	INIT_LIST_HEAD(&card->codec_dev_list);
+	INIT_LIST_HEAD(&card->platform_dev_list);
+
 	ret = snd_soc_register_card(card);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to register card\n");
@@ -1680,50 +2008,49 @@
 /* removes a socdev */
 static int soc_remove(struct platform_device *pdev)
 {
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
 	int i;
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
-	if (card->instantiated) {
-		run_delayed_work(&card->delayed_work);
+		if (card->instantiated) {
 
-		if (platform->remove)
-			platform->remove(pdev);
-
-		if (codec_dev->remove)
-			codec_dev->remove(pdev);
-
-		for (i = 0; i < card->num_links; i++) {
-			struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-			if (cpu_dai->remove)
-				cpu_dai->remove(pdev, cpu_dai);
+		/* make sure any delayed work runs */
+		for (i = 0; i < card->num_rtd; i++) {
+			struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+			run_delayed_work(&rtd->delayed_work);
 		}
 
+		/* remove and free each DAI */
+		for (i = 0; i < card->num_rtd; i++)
+			soc_remove_dai_link(card, i);
+
+		/* remove the card */
 		if (card->remove)
 			card->remove(pdev);
-	}
 
+		kfree(card->rtd);
+		snd_card_free(card->snd_card);
+	}
 	snd_soc_unregister_card(card);
-
 	return 0;
 }
 
 static int soc_poweroff(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	int i;
 
 	if (!card->instantiated)
 		return 0;
 
 	/* Flush out pmdown_time work - we actually do want to run it
 	 * now, we're shutting down so no imminent restart. */
-	run_delayed_work(&card->delayed_work);
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+		run_delayed_work(&rtd->delayed_work);
+	}
 
-	snd_soc_dapm_shutdown(socdev);
+	snd_soc_dapm_shutdown(card);
 
 	return 0;
 }
@@ -1746,53 +2073,42 @@
 };
 
 /* create a new pcm */
-static int soc_new_pcm(struct snd_soc_device *socdev,
-	struct snd_soc_dai_link *dai_link, int num)
-{
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_codec *codec = card->codec;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *codec_dai = dai_link->codec_dai;
-	struct snd_soc_dai *cpu_dai = dai_link->cpu_dai;
-	struct snd_soc_pcm_runtime *rtd;
+static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_pcm *pcm;
 	char new_name[64];
 	int ret = 0, playback = 0, capture = 0;
 
-	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
-	if (rtd == NULL)
-		return -ENOMEM;
-
-	rtd->dai = dai_link;
-	rtd->socdev = socdev;
-	codec_dai->codec = card->codec;
-
 	/* check client and interface hw capabilities */
 	snprintf(new_name, sizeof(new_name), "%s %s-%d",
-		 dai_link->stream_name, codec_dai->name, num);
+			rtd->dai_link->stream_name, codec_dai->name, num);
 
-	if (codec_dai->playback.channels_min)
+	if (codec_dai->driver->playback.channels_min)
 		playback = 1;
-	if (codec_dai->capture.channels_min)
+	if (codec_dai->driver->capture.channels_min)
 		capture = 1;
 
-	ret = snd_pcm_new(codec->card, new_name, codec->pcm_devs++, playback,
-		capture, &pcm);
+	dev_dbg(rtd->card->dev, "registered pcm #%d %s\n",num,new_name);
+	ret = snd_pcm_new(rtd->card->snd_card, new_name,
+			num, playback, capture, &pcm);
 	if (ret < 0) {
-		printk(KERN_ERR "asoc: can't create pcm for codec %s\n",
-			codec->name);
-		kfree(rtd);
+		printk(KERN_ERR "asoc: can't create pcm for codec %s\n", codec->name);
 		return ret;
 	}
 
-	dai_link->pcm = pcm;
+	rtd->pcm = pcm;
 	pcm->private_data = rtd;
-	soc_pcm_ops.mmap = platform->pcm_ops->mmap;
-	soc_pcm_ops.ioctl = platform->pcm_ops->ioctl;
-	soc_pcm_ops.copy = platform->pcm_ops->copy;
-	soc_pcm_ops.silence = platform->pcm_ops->silence;
-	soc_pcm_ops.ack = platform->pcm_ops->ack;
-	soc_pcm_ops.page = platform->pcm_ops->page;
+	soc_pcm_ops.mmap = platform->driver->ops->mmap;
+	soc_pcm_ops.pointer = platform->driver->ops->pointer;
+	soc_pcm_ops.ioctl = platform->driver->ops->ioctl;
+	soc_pcm_ops.copy = platform->driver->ops->copy;
+	soc_pcm_ops.silence = platform->driver->ops->silence;
+	soc_pcm_ops.ack = platform->driver->ops->ack;
+	soc_pcm_ops.page = platform->driver->ops->page;
 
 	if (playback)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
@@ -1969,95 +2294,6 @@
 EXPORT_SYMBOL_GPL(snd_soc_test_bits);
 
 /**
- * snd_soc_new_pcms - create new sound card and pcms
- * @socdev: the SoC audio device
- * @idx: ALSA card index
- * @xid: card identification
- *
- * Create a new sound card based upon the codec and interface pcms.
- *
- * Returns 0 for success, else error.
- */
-int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
-{
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_codec *codec = card->codec;
-	int ret, i;
-
-	mutex_lock(&codec->mutex);
-
-	/* register a sound card */
-	ret = snd_card_create(idx, xid, codec->owner, 0, &codec->card);
-	if (ret < 0) {
-		printk(KERN_ERR "asoc: can't create sound card for codec %s\n",
-			codec->name);
-		mutex_unlock(&codec->mutex);
-		return ret;
-	}
-
-	codec->socdev = socdev;
-	codec->card->dev = socdev->dev;
-	codec->card->private_data = codec;
-	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));
-
-	/* create the pcms */
-	for (i = 0; i < card->num_links; i++) {
-		ret = soc_new_pcm(socdev, &card->dai_link[i], i);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: can't create pcm %s\n",
-				card->dai_link[i].stream_name);
-			mutex_unlock(&codec->mutex);
-			return ret;
-		}
-		/* Check for codec->ac97 to handle the ac97.c fun */
-		if (card->dai_link[i].codec_dai->ac97_control && codec->ac97) {
-			snd_ac97_dev_add_pdata(codec->ac97,
-				card->dai_link[i].cpu_dai->ac97_pdata);
-		}
-	}
-
-	mutex_unlock(&codec->mutex);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
-
-/**
- * snd_soc_free_pcms - free sound card and pcms
- * @socdev: the SoC audio device
- *
- * Frees sound card and pcms associated with the socdev.
- * Also unregister the codec if it is an AC97 device.
- */
-void snd_soc_free_pcms(struct snd_soc_device *socdev)
-{
-	struct snd_soc_codec *codec = socdev->card->codec;
-#ifdef CONFIG_SND_SOC_AC97_BUS
-	struct snd_soc_dai *codec_dai;
-	int i;
-#endif
-
-	mutex_lock(&codec->mutex);
-	soc_cleanup_codec_debugfs(codec);
-#ifdef CONFIG_SND_SOC_AC97_BUS
-	for (i = 0; i < codec->num_dai; i++) {
-		codec_dai = &codec->dai[i];
-		if (codec_dai->ac97_control && codec->ac97 &&
-		    strcmp(codec->name, "AC97") != 0) {
-			soc_ac97_dev_unregister(codec);
-			goto free_card;
-		}
-	}
-free_card:
-#endif
-
-	if (codec->card)
-		snd_card_free(codec->card);
-	device_remove_file(socdev->dev, &dev_attr_codec_reg);
-	mutex_unlock(&codec->mutex);
-}
-EXPORT_SYMBOL_GPL(snd_soc_free_pcms);
-
-/**
  * snd_soc_set_runtime_hwparams - set the runtime hardware parameters
  * @substream: the pcm substream
  * @hw: the hardware parameters
